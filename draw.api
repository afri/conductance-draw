@ = require([
  'mho:std',
  'sjs:lru-cache',
  'sjs:object',
  'mho:server/storage',
]);

/*
 * sample:
 *
 * activeDrawings = {
 *     drawin-1-id: {
 *       segments: [
 *           {coord:[12, 23], sid:3},
 *           {x:12, y:23, sid:3, color: black, thickness:15},
 *           {x:12, y:23, sid:3},
 *         ],
 *     },
 *     ... 
 *     drawin-x-id: {
 *       segments: [
 *           {x:12 y:23 sid:3 color: black, thickness:15},
 *           {x:12 y:23 sid:3},
 *           {x:12 y:23 sid:3},
 *         ]
 *     },
 *   }
 */
var activeDrawings = {};
var drawingCache = @makeCache();
var db = @Storage('./drawingDB');

function finishDrawing(drawingId){
  var drawing = activeDrawings[drawingId];
  delete activeDrawings[drawingId];

  drawingCache.put(drawingId);
  db.put('drawing/'+drawingId, JSON.stringify(drawing));
}

function loadDrawing(drawingId){
   var drawing = drawingCache.get(drawingId);
   if (!drawing){
      drawing = db.get('drawing/'+drawingId);
      if (drawing){
        drawing = JSON.parse(drawing);
        drawingCache.put(drawingId, drawing);
      }
   }
   return drawing;
}

/*
 * Create a stream which outputs newly added segments to a drawing
 */
function changeStream(drawing){
  var clientId = drawing.clientCount;
  var idx = drawing.segments.length - 1;
  return @Stream(function(reciever){
    drawing.newSegmentEmitter.when({queue: true}){
      |client|
      idx++;
      if (client !== clientId){
        //XXX: I would somehow cause a queue overflow otherwise, should discuss
        spawn reciever(drawing.segments[idx]);
      }
    }
  });
}

/*
 * Create a function through which a client can submit new segments.
 */
function submitSegmentFunc(drawing){
  var clientId = drawing.clientCount;
  return function(segment){
    if (!segment.sid){
      segment.sid = ++drawing.strokeCount;
    }
    drawing.segments.push(segment);
    drawing.newSegmentEmitter.emit(clientId);
    drawing.lastEdited = new Date();
    return segment.sid;
  }
}

/*
 * Get a drawing.
 * Either:
 * - pass an id to fetch an existing drawing.
 * - call without arguments to create a new one.
 */
function getDrawing(drawingId){
  var log = '';
  if (!drawingId){
    //create a new drawing
    drawingId = generateDrawingId();
    while (activeDrawings[drawingId] !== undefined){
      drawingId = generateDrawingId();
    }
    log += "creating new drawing: #{drawingId}";
    activeDrawings[drawingId] = {
      lastEdited: new Date(),
      segments:[], 
      newSegmentEmitter:@Emitter(),
      clientCount: 0,
      strokeCount: 0,
    };
  } else if (!activeDrawings[drawingId]) {
    throw 'Unknown drawing id';
  } else {
    log += "fetching drawing: #{drawingId}";
  }
  activeDrawings[drawingId].clientCount++;

  log += "; for client \##{activeDrawings[drawingId].clientCount}";

  var drawing = activeDrawings[drawingId];

  drawing.changes = drawing .. changeStream;
  drawing.submitSegment = drawing .. submitSegmentFunc;

  console.log(log);
  
  return [
      drawingId, 
      drawing,
  ];
}
exports.getDrawing = getDrawing;

function getGallery(){
  return @Stream(function(reciever){
    db.query('drawing/', 'drawing/\xFF') .. @each(){
      |[binKey, binDraw]|
      console.log(binKey.toString());
      //would it be more efficient to stream the raw data?
      //probably, lets keep it simple for now
      reciever([
        binKey.toString(),
        JSON.parse(binDraw.toString()),
      ]);
    }
  })
}
exports.getGallery = getGallery;


//spawn a process which cleans up inactive drawings
function cleanService(){
  while (!hold(4000)){
    var c=0;
    activeDrawings .. @propertyPairs .. @each{
      |[drawingId, drawing]|
      //console.log("comparing '#{new Date.getTime()}' with #{drawing.lastEdited.getTime()}");
      if (new Date().getTime() - drawing.lastEdited.getTime() > 60000){
        //hasn't been touched for a minute
        finishDrawing(drawingId);
        c++;
      }
    }
    console.info(c>0?"cleaned up #{c} drawings":"did not clean anything up");
  } 
}
spawn cleanService();

var words = [
  ['very', 'quite', 'disturbingly', 'satisfyingly', 'distinguishably'],
  ['large', 'small', 'digestable', 'weird', 'wrong'],
  ['football', 'fish', 'plate', 'horse', 'sandwich', 'ashtray'],
];
function generateDrawingId(){
    var rand = a -> a[Math.floor(Math.random() * a.length)];
    return (words .. @map(rand)).join('-');
}

