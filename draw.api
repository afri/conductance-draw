@ = require([
  'mho:std',
  'sjs:object',
  {name:'lru', id:'sjs:lru-cache'},
  {name: 'storage', id:'./StorageBackfill.sjs'},
  {name:'ids', id:'./ids.sjs'},
]);

/*
 * Drawing datastructure:
 */
var schema = {
  id: null,
  segments: [/*
    {coord:[12, 23], sid:3},
    {x:12, y:23, sid:3, color: black, thickness:15},
    {x:12, y:23, sid:3},
  */],
};
var activeSchema = {
  newSegmentEmitter:@Emitter(),
  clientCount: 0,
  strokeCount: 0,
  clients: [/*
    {id: 1},
    {id: 3},
  */],
};

var
  activeDrawings = {},
  drawingCache = @lru.makeCache(),
  db = @storage.Storage('./drawingDB');

function loadDrawing(drawingId){
  var drawing = undefined;
  //get it from the cache
  if ( (drawing=drawingCache.get(drawingId)) !== null ){
    return drawing;
  }
  //get it from the db and cache it
  db.get('drawing/'+drawingId){
    |drawingData|
    drawing = JSON.parse(drawingData.toString());
    //add fields necessary for active drawing 
    drawing = activeSchema .. @clone .. @merge(drawing);
    drawingCache.put(drawingId, drawing);
  }
  return drawing;
}

function putDrawing(drawingId, drawing){
  //store in the cache, if only for marking as recently used
  drawingCache.put(drawingId, drawing);
  //write to the database
  var d = schema .. @clone .. @override(drawing); //conform to schema
  db.put('drawing/'+drawingId, JSON.stringify(d)); //???: spawn?
}

/*
 * Create a stream which outputs newly added segments to a drawing
 * Initially the stream outputs all segments
 * The stream also send's empty packets periodically to check if the client is still present 
 *  and if not; cleans up accordingly
 */
function segmentStream(drawing, clientId){
  function unregisterClient(){
    //remove the client and cleanup if it was the last
    drawing.clients = drawing.clients .. @filter(c->c.id != clientId) .. @toArray;
    if (!drawing.clients.length){
      console.log("Will cleanup active drawing: #{drawing.id}");
      delete activeDrawings[drawing.id];
    }
  }
  return @Stream(function(reciever){
    var idx = 0, once = false;;
    while (1) {
      var sendEmpty = false;
      waitfor {
        drawing.newSegmentEmitter .. @wait();
      } or {
        hold(30*1000);
        sendEmpty = true;
      } or {
        if (once) hold();
        else once = true;
      }
      var segments = 
        drawing.segments.slice(idx)
        .. @filter(s->s.clientId !== clientId)
        .. @toArray;
      if (segments.length || sendEmpty){
        try {
          reciever(segments);
        } catch (e){
          //can't call the function on the client
          "ureka catched" .. console.log;
          unregisterClient();
        } retract {
          //client has disconnected
          "ureka retracted" .. console.log;
          unregisterClient();
        }
      }
      idx = drawing.segments.length;
    }
  });
}

/*
 * Create a function through which a client can submit new segments.
 */
function submitSegmentFunc(drawing, clientId){
  var clientId = drawing.clientCount;
  return function(segment){
    if (!segment.sid){
      segment.sid = ++drawing.strokeCount;
    }
    drawing.segments.push(segment .. @merge({clientId:clientId}));
    drawing.newSegmentEmitter.emit();
    drawing.lastEdited = new Date()
    putDrawing(drawing.id, drawing);
    return segment.sid;
  }
}

/*
 * Get a drawing.
 * Either:
 * - pass an id to fetch an existing drawing.
 * - call without arguments to create a new one.
 */
function getDrawing(drawingId){
  var log = '';
  var drawing;
  if (!drawingId){
    //create a new drawing
    //TODO: Create function which only checks the ID and doesn't load the drawing
    do {
      drawingId = @ids.newID();
    } while (loadDrawing(drawingId)) 
    log += "creating new drawing: #{drawingId}";
    drawing = activeDrawings[drawingId] = schema .. @merge(activeSchema)
    drawing.id = drawingId;
    putDrawing(drawingId, drawing)
  } else if (!loadDrawing(drawingId)){
    throw 'Unknown drawing id';
  } else {
    log += "fetching drawing: #{drawingId}";
    drawing = activeDrawings[drawingId] = loadDrawing(drawingId);
  }
  //prepare the drawing for the client(s)
  drawing.clientCount++;
  var clientId = drawing.clientCount;
  drawing.clients.push({id: clientId});
  
  log += "; for client \##{activeDrawings[drawingId].clientCount}";
  //print to server console 
  console.info(log);
  return [
      drawingId, 
      {
        id: null,
        submitSegment: null,
        segments: null
      } .. @merge(
          drawing, 
          {
            segments: drawing .. segmentStream(clientId), 
            submitSegment: drawing .. submitSegmentFunc(clientId),
          }
        ),
  ];
}
exports.getDrawing = getDrawing;

function getGallery(){
  return @Stream(function(reciever){
    db.query('drawing/', 'drawing/\xFF') .. @each(){
      |[binKey, binDraw]|
      var key = binKey.toString().replace(/^drawing\//, '');
      reciever(getDrawing(key));
    }
  })
}
exports.getGallery = getGallery;
